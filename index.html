<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Princess Warrior Quest - Powerups & Trail</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    background: #a3d9ff;
    font-family: 'Comic Sans MS', cursive, sans-serif;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  #gameCanvas {
    display: block;
    background: #9ee6ff;
    margin: 0 auto;
    touch-action: none;
    image-rendering: pixelated;
    border: 5px solid #f2c1d1;
    border-radius: 15px;
  }
  #ui {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 90vw;
    max-width: 500px;
    display: flex;
    justify-content: space-around;
    user-select: none;
  }
  button.control {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    background: #ffb6c1;
    box-shadow: 0 4px 0 #d67a8e;
    font-size: 30px;
    color: white;
    font-weight: bold;
    user-select: none;
  }
  button.control:active {
    background: #ff84a0;
    box-shadow: 0 2px 0 #d67a8e;
    transform: translateY(2px);
  }
  #coinCounter {
    position: fixed;
    top: 10px;
    left: 10px;
    font-size: 1.5em;
    color: #ff6699;
    user-select: none;
  }
  #powerupIndicator {
    position: fixed;
    top: 40px;
    left: 10px;
    font-size: 1.2em;
    color: #ff3399;
    user-select: none;
    min-width: 150px;
  }
  #endScreen {
    position: fixed;
    top:0; left:0; right:0; bottom:0;
    background: #fce4eccc;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 2.5em;
    font-weight: bold;
    color: #ff6699;
    text-align: center;
    visibility: hidden;
    flex-direction: column;
    padding: 20px;
  }
  #endScreen.animate {
    animation: fadein 2s ease forwards;
  }
  @keyframes fadein {
    0% {opacity: 0; transform: scale(0.7);}
    100% {opacity: 1; transform: scale(1);}
  }
</style>
</head>
<body>

<canvas id="gameCanvas" width="480" height="320"></canvas>

<div id="ui">
  <button id="leftBtn" class="control">â—€</button>
  <button id="jumpBtn" class="control">â–²</button>
  <button id="rightBtn" class="control">â–¶</button>
</div>

<div id="coinCounter">Coins: 0</div>
<div id="powerupIndicator"></div>

<div id="endScreen">I love you my pretty princess ðŸ’–</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  // Scale canvas for mobile crispness
  const scale = window.devicePixelRatio || 1;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  canvas.width = W * scale;
  canvas.height = H * scale;
  ctx.scale(scale, scale);

  // Game variables
  let keys = { left: false, right: false, jump: false };
  const gravity = 0.6;
  const friction = 0.7;

  // Player properties
  const player = {
    x: 50,
    y: H - 50,
    w: 32,
    h: 48,
    vx: 0,
    vy: 0,
    speed: 3,
    jumpPower: 12,
    jumping: false,
    color: '#ff66aa',
    trail: [],
    powerups: {
      speedBoost: 0,
      jumpBoost: 0,
    }
  };

  // Coin count
  let totalCoins = 0;

  // Camera offset
  let camX = 0;

  // Level data - platforms, spikes, enemies, coins with powerups
  const levels = [
    {
      length: 1100,
      platforms: [
        {x: 0, y: H - 20, w: 1100, h: 20},
        {x: 200, y: H - 70, w: 60, h: 15},
        {x: 280, y: H - 120, w: 60, h: 15},
        {x: 400, y: H - 70, w: 60, h: 15},
        {x: 480, y: H - 150, w: 60, h: 15},
        {x: 600, y: H - 70, w: 60, h: 15},
        {x: 680, y: H - 120, w: 60, h: 15},
        {x: 800, y: H - 70, w: 60, h: 15},
        {x: 880, y: H - 150, w: 60, h: 15},
        {x: 950, y: H - 70, w: 60, h: 15},
      ],
      spikes: [
        {x: 350, y: H - 35, w: 20, h: 15},
        {x: 720, y: H - 35, w: 20, h: 15},
        {x: 920, y: H - 35, w: 20, h: 15},
      ],
      coins: [
        {x: 220, y: H - 100, w: 16, h: 16, powerup: null},
        {x: 300, y: H - 150, w: 16, h: 16, powerup: 'speedBoost'},
        {x: 480, y: H - 180, w: 16, h: 16, powerup: null},
        {x: 600, y: H - 100, w: 16, h: 16, powerup: 'jumpBoost'},
        {x: 880, y: H - 180, w: 16, h: 16, powerup: null},
      ],
      enemies: [
        {x: 450, y: H - 35 - 32, w: 32, h: 32, vx: 1.5, range: [450, 510], color: '#ff5577'},
        {x: 750, y: H - 35 - 32, w: 32, h: 32, vx: 2, range: [720, 780], color: '#ff5577'},
      ],
    }
  ];

  let currentLevelIndex = 0;
  let currentLevel = levels[currentLevelIndex];

  // Player respawn start position
  const startX = 50;
  const startY = H - 50;

  // UI elements
  const coinCounter = document.getElementById('coinCounter');
  const powerupIndicator = document.getElementById('powerupIndicator');
  const endScreen = document.getElementById('endScreen');

  // Input handlers
  function keyDown(e) {
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.jump = true;
  }
  function keyUp(e) {
    if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
    if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') keys.jump = false;
  }
  window.addEventListener('keydown', keyDown);
  window.addEventListener('keyup', keyUp);

  // Touch controls
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const jumpBtn = document.getElementById('jumpBtn');

  leftBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.left = true; });
  leftBtn.addEventListener('touchend', e => { e.preventDefault(); keys.left = false; });
  rightBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.right = true; });
  rightBtn.addEventListener('touchend', e => { e.preventDefault(); keys.right = false; });
  jumpBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.jump = true; });
  jumpBtn.addEventListener('touchend', e => { e.preventDefault(); keys.jump = false; });

  // Collision detection helper
  function rectIntersect(r1, r2) {
    return !(r2.x > r1.x + r1.w || 
             r2.x + r2.w < r1.x || 
             r2.y > r1.y + r1.h ||
             r2.y + r2.h < r1.y);
  }

  // Reset player to start of current level
  function resetPlayer() {
    player.x = startX;
    player.y = startY;
    player.vx = 0;
    player.vy = 0;
    player.jumping = false;
    player.trail = [];
    player.powerups.speedBoost = 0;
    player.powerups.jumpBoost = 0;
    powerupIndicator.textContent = '';
  }

  // Handle enemy-player collisions
  function handleEnemyCollision(enemy, i) {
    if (rectIntersect(player, enemy)) {
      // Check if player hits enemy from top
      if (player.vy > 0 && (player.y + player.h) - enemy.y < 15) {
        // Enemy defeated
        currentLevel.enemies.splice(i, 1);
        player.vy = -10; // bounce up
      } else {
        // Player hurt - reset level
        resetPlayer();
      }
    }
  }

  // Handle coin collection & powerups
  function handleCoinCollection(coin, i) {
    if (rectIntersect(player, coin)) {
      // Remove coin
      currentLevel.coins.splice(i, 1);
      totalCoins++;
      coinCounter.textContent = `Coins: ${totalCoins}`;
      if (coin.powerup) {
        activatePowerup(coin.powerup);
      }
    }
  }

  // Activate powerup and set timers
  function activatePowerup(type) {
    const duration = 5000; // 5 seconds duration
    if (type === 'speedBoost') {
      player.powerups.speedBoost = Date.now() + duration;
      powerupIndicator.textContent = 'Speed Boost!';
    } else if (type === 'jumpBoost') {
      player.powerups.jumpBoost = Date.now() + duration;
      powerupIndicator.textContent = 'Jump Boost!';
    }
  }

  // Update powerup timers and effects
  function updatePowerups() {
    const now = Date.now();
    if (player.powerups.speedBoost && player.powerups.speedBoost < now) {
      player.powerups.speedBoost = 0;
      powerupIndicator.textContent = '';
    }
    if (player.powerups.jumpBoost && player.powerups.jumpBoost < now) {
      player.powerups.jumpBoost = 0;
      powerupIndicator.textContent = '';
    }
  }

  // Game end handler
  function endGame() {
    running = false;
    endScreen.style.visibility = 'visible';
    endScreen.classList.add('animate');
  }

  // Load next level or end game
  function nextLevel() {
    currentLevelIndex++;
    if (currentLevelIndex >= levels.length) {
      endGame();
    } else {
      currentLevel = levels[currentLevelIndex];
      resetPlayer();
      camX = 0;
      running = true;
      endScreen.style.visibility = 'hidden';
      endScreen.classList.remove('animate');
      loop();
    }
  }

  // Update player movement and physics
  function updatePlayer() {
    // Powerup speed multiplier
    let speedMult = player.powerups.speedBoost ? 1.7 : 1;
    let jumpPower = player.powerups.jumpBoost ? 16 : player.jumpPower;

    // Left/right movement
    if (keys.left) player.vx = -player.speed * speedMult;
    else if (keys.right) player.vx = player.speed * speedMult;
    else player.vx *= friction;

    // Jumping
    if (keys.jump && !player.jumping) {
      player.vy = -jumpPower;
      player.jumping = true;
    }

    // Gravity
    player.vy += gravity;

    // Store previous position for trail when moving horizontally
    if (player.vx !== 0) {
      player.trail.push({x: player.x + player.w / 2, y: player.y + player.h - 10, alpha: 1});
      if (player.trail.length > 15) player.trail.shift();
    } else {
      player.trail = []; // clear trail if no horizontal movement
    }

    // Update trail alpha fade
    for (let t of player.trail) {
      t.alpha -= 
